<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sunzhujie.github.io</id>
    <title>阿杰笔记</title>
    <updated>2019-08-17T00:44:05.405Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sunzhujie.github.io"/>
    <link rel="self" href="https://sunzhujie.github.io/atom.xml"/>
    <subtitle>等你等了八万里，如期未至</subtitle>
    <logo>https://sunzhujie.github.io/images/avatar.png</logo>
    <icon>https://sunzhujie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 阿杰笔记</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot面试题]]></title>
        <id>https://sunzhujie.github.io/post/springboot-mian-shi-ti</id>
        <link href="https://sunzhujie.github.io/post/springboot-mian-shi-ti">
        </link>
        <updated>2019-08-16T13:33:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是-spring-boot">什么是 Spring Boot？</h2>
<p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<h2 id="为什么要用-spring-boot优点">为什么要用 Spring Boot？优点</h2>
<p>独立运行<br>
简化配置<br>
自动配置<br>
无代码生成和XML配置<br>
应用监控<br>
上手容易</p>
<h2 id="spring-boot-的核心配置文件有哪几个它们的区别是什么">Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</h2>
<p>Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。</p>
<p>application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。</p>
<p>bootstrap 配置文件有以下几个应用场景。</p>
<p>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；<br>
一些固定的不能被覆盖的属性；<br>
一些加密/解密的场景；</p>
<h2 id="spring-boot-的配置文件有哪几种格式它们有什么区别">Spring Boot 的配置文件有哪几种格式？它们有什么区别？</h2>
<p>.properties 和 .yml，它们的区别主要是书写格式不同。<br>
1).properties<br>
app.user.name = javastack<br>
2).yml<br>
app:<br>
user:<br>
name: javastack<br>
另外，.yml 格式不支持 @PropertySource 注解导入配置。</p>
<h2 id="spring-boot-的核心注解是哪个它主要由哪几个注解组成的">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2>
<p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：<br>
@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。<br>
@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：<br>
@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。注解来开启 Spring Boot 的各项能力，如自动配置、组件扫描等<br>
@ComponentScan：Spring组件扫描</p>
<h2 id="开启-spring-boot-特性有哪几种方式">开启 Spring Boot 特性有哪几种方式？</h2>
<p>1）继承spring-boot-starter-parent项目<br>
2）导入spring-boot-dependencies项目依赖</p>
<h2 id="spring-boot-需要独立的容器运行吗">Spring Boot 需要独立的容器运行吗？</h2>
<p>可以不需要，内置了 Tomcat/ Jetty 等容器。</p>
<h2 id="运行-spring-boot-有哪几种方式">运行 Spring Boot 有哪几种方式？</h2>
<p>1）打包用命令或者放到容器中运行<br>
2）用 Maven/ Gradle 插件运行<br>
3）直接执行 main 方法运行<br>
Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。</p>
<h2 id="spring-boot-自动配置原理是什么">Spring Boot 自动配置原理是什么？</h2>
<p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。</p>
<h2 id="如何在-spring-boot-启动的时候运行一些特定的代码">如何在 Spring Boot 启动的时候运行一些特定的代码？</h2>
<p>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法，具体请看这篇文章</p>
<h2 id="springboot-实现热部署有哪几种方式">SpringBoot 实现热部署有哪几种方式？</h2>
<p>主要有两种方式：<br>
Spring Loaded<br>
Spring-boot-devtools</p>
<h2 id="spring-boot-可以兼容老-spring-项目吗如何做">Spring Boot 可以兼容老 Spring 项目吗，如何做？</h2>
<p>可以兼容，使用 <code>@ImportResource</code> 注解导入老 Spring 项目配置文件。</p>
<h2 id="保护-spring-boot-应用有哪些方法">保护 Spring Boot 应用有哪些方法？</h2>
<p>在生产中使用HTTPS<br>
使用Snyk检查你的依赖关系<br>
升级到最新版本<br>
启用CSRF保护<br>
使用内容安全策略防止XSS攻击</p>
<h2 id="spring-boot-2x-有什么新特性与-1x-有什么区别">Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</h2>
<p>配置变更<br>
JDK 版本升级<br>
第三方类库升级<br>
响应式 Spring 编程支持<br>
HTTP/2 支持<br>
配置属性绑定</p>
<h2 id="你如何理解-spring-boot-配置加载顺序">你如何理解 Spring Boot 配置加载顺序？</h2>
<p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。<br>
1）properties文件；<br>
2）YAML文件；<br>
3）系统环境变量；<br>
4）命令行参数；</p>
<h2 id="spring-boot-支持哪些日志框架推荐和默认的日志框架是哪个">Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h2>
<p>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架</p>
<h2 id="spring-boot-有哪几种读取配置的方式">Spring Boot 有哪几种读取配置的方式？</h2>
<p>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变量</p>
<h2 id="如何在-spring-boot-启动的时候运行一些特定的代码-2">如何在 Spring Boot 启动的时候运行一些特定的代码？</h2>
<p>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC面试题]]></title>
        <id>https://sunzhujie.github.io/post/springmvc-mian-shi-ti</id>
        <link href="https://sunzhujie.github.io/post/springmvc-mian-shi-ti">
        </link>
        <updated>2019-08-16T00:43:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springmvc工作原理">SpringMVC工作原理</h2>
<p><img src="https://upload-images.jianshu.io/upload_images/4189525-1e95637030237aea.png?imageMogr2/auto-orient/" alt=""><br>
【用户发送请求到前端控制器dispatcherservlet，前端控制器接收到请求之后调用处理器映射器，根据请求url找到具体的处理器，生成处理器对象返回给前端控制器，前端控制器通过处理器适配器调用处理器，执行处理器返回ModelAndView，处理器适配器将ModelAndView返回给前端控制器，前端控制器将ModelAndView传递给视图解析器，视图解析器解析后返回具体的view，前端控制器对view进行渲染视图后响应给用户】<br>
1、用户发送请求至前端控制器DispatcherServlet<br>
2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>
3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。【此时处理器映射器返回的处理器对象包含：包名+类名+方法名】<br>
4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器<br>
5、执行处理器(Controller，也叫后端控制器)。<br>
6、Controller执行完成返回ModelAndView<br>
7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet<br>
8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器【ModelAndView内部其实就是一个jsp文件的路径】<br>
9、ViewReslover解析（读取jsp文件到内存中）后返回具体View<br>
10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。<br>
11、DispatcherServlet响应用户<br>
12、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？<br>
是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Spring的面试题]]></title>
        <id>https://sunzhujie.github.io/post/guan-yu-spring</id>
        <link href="https://sunzhujie.github.io/post/guan-yu-spring">
        </link>
        <updated>2019-08-15T12:06:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是spring">什么是Spring</h2>
<p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p>
<h2 id="使用spring框架的好处是什么">使用Spring框架的好处是什么？</h2>
<p><strong>轻量</strong>：Spring 是轻量的，基本的版本大约2MB。<br>
<strong>控制反转</strong>：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>
<strong>面向切面的编程(AOP)</strong>：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>
<strong>容器</strong>：Spring 包含并管理应用中对象的生命周期和配置。<br>
MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br>
<strong>事务管理</strong>：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br>
<strong>异常处理</strong>：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常</p>
<h2 id="核心容器应用上下文-模块">核心容器（应用上下文) 模块</h2>
<p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<h2 id="beanfactory-beanfactory-实现举例">BeanFactory – BeanFactory 实现举例。</h2>
<p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<h2 id="解释aop模块">解释AOP模块</h2>
<p>AOP模块用于发给我们的Spring应用做面向切面的开发， 很多支持由AOP联盟提供，这样就确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring。</p>
<h2 id="解释jdbc抽象和dao模块">解释JDBC抽象和DAO模块。</h2>
<p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
<h2 id="spring配置文件">Spring配置文件</h2>
<p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p>
<h2 id="什么是spring-ioc-容器">什么是Spring IOC 容器？</h2>
<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h2 id="有哪些不同类型的ioc依赖注入方式">有哪些不同类型的IOC（依赖注入）方式？</h2>
<p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。<br>
Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。<strong>最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</strong></p>
<h2 id="什么是spring-beans">什么是Spring beans?</h2>
<p>** Spring beans 是那些形成Spring应用的主干的java对象**。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<bean/> 的形式定义。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot整合Mybtatis-Plus]]></title>
        <id>https://sunzhujie.github.io/post/springboot-zheng-he-mybtatis-plus</id>
        <link href="https://sunzhujie.github.io/post/springboot-zheng-he-mybtatis-plus">
        </link>
        <updated>2019-08-15T11:49:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h2 id="添加依赖">添加依赖</h2>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="特性">特性</h2>
<h3 id="无侵入">无侵入：</h3>
<p>只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</p>
<h3 id="损耗小">损耗小：</h3>
<p>启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</p>
<h3 id="强大的-crud-操作">强大的 CRUD 操作：</h3>
<p>内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</p>
<h3 id="支持-lambda-形式调用">支持 Lambda 形式调用：</h3>
<p>通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p>
<h3 id="支持主键自动生成">支持主键自动生成：</h3>
<p>支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</p>
<h3 id="支持-activerecord-模式">支持 ActiveRecord 模式：</h3>
<p>支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</p>
<h3 id="支持自定义全局通用操作">支持自定义全局通用操作：</h3>
<p>支持全局通用方法注入（ Write once, use anywhere ）</p>
<h3 id="内置代码生成器">内置代码生成器：</h3>
<p>采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p>
<h3 id="内置分页插件">内置分页插件：</h3>
<p>基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</p>
<h3 id="分页插件支持多种数据库">分页插件支持多种数据库：</h3>
<p>支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库</p>
<h3 id="内置性能分析插件">内置性能分析插件：</h3>
<p>可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</p>
<h3 id="内置全局拦截插件">内置全局拦截插件：</h3>
<p>提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</p>
<h2 id="通用mapper">通用Mapper</h2>
<ul>
<li>实体类Book.java</li>
</ul>
<pre><code>@TableName(&quot;book&quot;) //当数据库表名与实体类不同时
public class Book {
    //使用TableId注解标记主键对应的属性
    //value：主键的字段名
    //type：主键的生成策略，IdType.AUTO：使用数据库的自增
    @TableId(value = &quot;id&quot;,type = IdType.AUTO)
    private Long id;
    private String name;
    private String author;
    private Double price;
		@TableLogic //逻辑删除
		private Integer  status;
		@TableField(exist = false) //当此属性在表中没有时
		priver  String NO;
    //省略getter和setter
}
</code></pre>
<ul>
<li>让Mapper接口继承自BaseMapper接口</li>
</ul>
<pre><code class="language-package">
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.oaec.springbootmp.entity.Book;

public interface BookMapper extends BaseMapper&lt;Book&gt; {
}
</code></pre>
<ul>
<li>测试根据编号查询</li>
</ul>
<pre><code class="language-@RunWith(SpringRunner.class)">@SpringBootTest
public class SpringbootMpApplicationTests {

    @Autowired
    private BookMapper bookMapper;

    @Test
    public void contextLoads() {
        Book book = bookMapper.selectById(1001);
        System.out.println(&quot;book = &quot; + book);
    }

}
</code></pre>
<h3 id="增删改">增删改</h3>
<ul>
<li>插入数据</li>
</ul>
<pre><code>Book book = new Book();
book.setName(&quot;红楼梦&quot;);
book.setAuthor(&quot;曹雪芹&quot;);
book.setPrice(19.92);
//返回值代表影响数据库的行数
int insert = bookMapper.insert(book);
System.out.println(&quot;insert = &quot; + insert);
//插入成功之后自动将生成的主键保存在主键对应的属性
System.out.println(&quot;book = &quot; + book);
</code></pre>
<ul>
<li>根据主键更新</li>
</ul>
<pre><code>Book book = new Book();
book.setId(1003L);
//        book.setName(&quot;三国演义&quot;);
book.setAuthor(&quot;罗贯中&quot;);
//根据主键进行数据更新，只会更新赋值的属性，值为null的属性不会进行修改
int i = bookMapper.updateById(book);
System.out.println(&quot;i = &quot; + i);
</code></pre>
<p>自定义条件更新数据</p>
<ul>
<li>Book book = new Book();</li>
</ul>
<pre><code>book.setPrice(10D);
//将价格大于20的书，价格修改为10
//第一个参数的属性会拼接在set之后，第二个参数的条件会拼接在where之后
int update = bookMapper.update(book,
        Wrappers.&lt;Book&gt;lambdaUpdate().gt(Book::getPrice, 20));
System.out.println(&quot;update = &quot; + update);
</code></pre>
<ul>
<li>根据主键删除<br>
<code>bookMapper.deleteById(1161463992506478594L);</code></li>
<li>根据主键批量删除</li>
</ul>
<pre><code>List&lt;Long&gt; idList = Arrays.asList(1006L, 1007L);
int i = bookMapper.deleteBatchIds(idList);
</code></pre>
<ul>
<li>使用Map作为条件删除</li>
</ul>
<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
map.put(&quot;name&quot;,&quot;西游记&quot;);
int i = bookMapper.deleteByMap(map);
</code></pre>
<ul>
<li>使用条件构造器删除</li>
</ul>
<pre><code>int delete = bookMapper.delete(Wrappers.&lt;Book&gt;lambdaUpdate()
                .lt(Book::getPrice, 20));
</code></pre>
<h3 id="查询">查询</h3>
<ul>
<li>根据主键查询<br>
<code>Book book = bookMapper.selectById(1003)</code></li>
<li>查询全部<br>
<code>List&lt;Book&gt; books = bookMapper.selectList(null);</code></li>
<li>自定义查询条件</li>
</ul>
<pre><code>//查询价格大于10元的书
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;lambdaQuery()
                .gt(Book::getPrice, 10));
//查询价格大于10元的书，书名为“三国演义”
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;lambdaQuery()
                .gt(Book::getPrice, 10)
                .eq(Book::getName, &quot;三国演义&quot;));
//查询书名包含“三”的书
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;lambdaQuery()
                .like(Book::getName, &quot;三&quot;));
//查询书名以“三”开头的书
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;lambdaQuery()
                .likeRight(Book::getName, &quot;三&quot;));
</code></pre>
<h3 id="分页查询">分页查询</h3>
<ul>
<li>配置类：MybatisPlusConfig</li>
</ul>
<pre><code>/**
 * 配置类
 */
@Configuration
public class MybatisPlusConfig {
    @Bean
    public PaginationInterceptor paginationInterceptor(){
        return new PaginationInterceptor();
    }
}
查询第1页，每页2条
//查询结果为实体类型
IPage&lt;Book&gt; page = bookMapper.selectPage(new Page&lt;Book&gt;(1, 2), null);
//查询结果为Map类型
IPage&lt;Map&lt;String, Object&gt;&gt; page = bookMapper.selectMapsPage(new Page&lt;&gt;(1, 2), null);
IPage接口
List getRecords(); 获取查询记录
long getTotal(); 获取总数量
long getPages() 获取总页数
通用Service
Service接口继承IService
import com.baomidou.mybatisplus.extension.service.IService;
import com.oaec.springbootmp.entity.Book;

public interface BookService extends IService&lt;Book&gt; {
}
Service实现类继承ServiceImpl，实现自己的Service接口
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.oaec.springbootmp.entity.Book;
import com.oaec.springbootmp.mapper.BookMapper;
import com.oaec.springbootmp.service.BookService;
import org.springframework.stereotype.Service;

@Service(&quot;bookService&quot;)
public class BookServiceImpl extends ServiceImpl&lt;BookMapper, Book&gt; implements BookService {
}
</code></pre>
<h2 id="逻辑删除">逻辑删除</h2>
<pre><code>application.yml配置文件中配置代表是否删除的数值
mybatis-plus:
  global-config:
    db-config:
      logic-delete-value: 0 # 逻辑已删除值(默认为 0)
      logic-not-delete-value: 1 # 逻辑未删除值(默认为 1)
实体中表示是否删除的属性添加注解
public class Book {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String name;
    private Double price;
    //逻辑删除字段
    @TableLogic
    private Integer status;
    private Timestamp createTime;
    //省略getter和setter
}
执行查询
List&lt;Book&gt; books = bookMapper.selectList(null);
books.forEach(System.out::println);
​	执行的SQL

SELECT id,name,price,status,create_time FROM book WHERE status=1
执行删除
int i = bookMapper.deleteById(1L);
System.out.println(&quot;i = &quot; + i);
​	执行的SQL

UPDATE book SET status=0 WHERE id=? AND status=1
备注
jdk1.8才支持lambda表达式，如果使用jdk1.8之前的版本，可以使用Wrappers.query()
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;query().like(&quot;name&quot;, &quot;三&quot;));
for (Book book : books) {
    System.out.println(&quot;book = &quot; + book);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Mybatis-plus所需要的配置]]></title>
        <id>https://sunzhujie.github.io/post/guan-yu-mybatis-plus-suo-xu-yao-de-pei-zhi</id>
        <link href="https://sunzhujie.github.io/post/guan-yu-mybatis-plus-suo-xu-yao-de-pei-zhi">
        </link>
        <updated>2019-08-15T11:44:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="maven">maven</h2>
<pre><code>&lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.1.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h2 id="yml">YML</h2>
<pre><code>mybatis-plus:
  global-config:
    db-config:
      logic-delete-value: 0 //默认逻辑已删除
      logic-not-delete-value: 1  //默认逻辑未删除
  configuration:
    map-underscore-to-camel-case: true //驼峰命名法
  type-aliases-package: com.oaec.tabledemo.po; //类别名
  mapper-locations: classpath:mapper/*.xml //mapper
</code></pre>
<h2 id="其他yml">其他YML</h2>
<pre><code>spring:
  datasource:
    url: jdbc:mysql://localhost:3306/demo
    driver-class-name: com.mysql.jdbc.Driver
    username: root
    password: 123456
  thymeleaf:
    cache: false
  jackson:
    date-format: yyyy-MM-dd
    time-zone: GMT+8 //时区
mybatis:
  configuration:
    map-underscore-to-camel-case: true
  type-aliases-package: com.oaec.tabledemo.po;
  mapper-locations: classpath:mapper/*.xml
server:
  port: 8888
pagehelper:
  helper-dialect: mysql
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bootstrap-Table的使用]]></title>
        <id>https://sunzhujie.github.io/post/bootstrap-table</id>
        <link href="https://sunzhujie.github.io/post/bootstrap-table">
        </link>
        <updated>2019-08-15T11:34:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="所需要的文件">所需要的文件</h2>
<p><img src="https://sunzhujie.github.io/post-images/1565869358782.png" alt=""></p>
<h2 id="html">HTML</h2>
<pre><code>  &lt;script type=&quot;text/javascript&quot;&gt;
        function del(id){
            alert(id)
        }
        function edit(id){
            alert(id)
        }
        $(function () {
            $(&quot;#booktable&quot;).bootstrapTable({
                url:&quot;/books&quot;,
                method:&quot;get&quot;,
                dataField:&quot;data&quot;,
                pagination:true,//开启分页
                sidePagination:'client', //分页方式
                pageNumber:1, //默认显示第几页
                pageSize:5, //每条页数
                search:true, //开启前端搜索
                strictSearch:false,// 设置为true 搜索模式为完全匹配,不支持模糊查询
                showColumns:true, // 开启列的显示隐藏
                showRefresh: true,
                minimumCountColumns: 2,//最少显示多少列
                uniqueId:&quot;id&quot; ,//每条记录的唯一标识
                columns:[
                    {
                        checkbox:true
                    },
                    {
                        field:&quot;id&quot;,
                        title:&quot;编号&quot;
                    },
                    {
                        field:&quot;name&quot;,
                        title:&quot;书名&quot;
                    },
                    {
                        field:&quot;author&quot;,
                        title:&quot;作者&quot;
                    },
                    {
                        field:&quot;price&quot;,
                        title:&quot;价格&quot;
                    },

                    {
                        field:&quot;status&quot;,
                        title:&quot;状态&quot;,
                        formatter :function (value,row,index) {
                            if(value ===0){
                                return '&lt;span class=&quot;label label-danger&quot;&gt;禁用&lt;/span&gt;';
                            }else if( value ===1){
                                return '&lt;span class=&quot;label label-success&quot;&gt;正常&lt;/span&gt;';
                            }
                        }
                    },
                    {
                        field:&quot;createTime&quot;,
                        title:&quot;时间&quot;
                    },
                    {
                        title:&quot;操作&quot;,
                        formatter :function (value,row,index) {
                            return '&lt;button class=&quot;btn btn-sm btn-primary&quot; onlick=&quot;edit('+row.id+')&quot;&gt;修改&lt;/button&gt;\n'+
                                    '&lt;button class=&quot;btn btn-sm btn-danger&quot; onlick=&quot;del('+row.id+')&quot;&gt;删除&lt;/button&gt; ';
                        }
                    }
                ]
            })
        })

    &lt;/script&gt;
&lt;/head&gt;
&lt;body class=&quot;container&quot;&gt;
        &lt;h1 class=&quot;&quot;&gt;图书列表&lt;/h1&gt;
        &lt;button class=&quot;btn btn-success&quot;&gt;添加图书&lt;/button&gt;
    &lt;table id=&quot;booktable&quot; class=&quot;table table-striped&quot;&gt;&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
</feed>